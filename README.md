# Project "3A" Caruso&Fallica DSBD 2020
## Project for Distributed Systems Big Data 2020
### Made by:
- **Caruso Bartolomeo**
- **Giuseppe Fallica**

---

## 1. Aim of this project
This project aims at creating a microservice that will be used to handle payments for an e-commerce distributed application.

In order to develop this project we have used the following elements:
- **MySQL database:** relational database, used inside a Docker container 
- **Kafka messaging system:** open source distributed event streaming platform, used to publish into a specific topic errors and critical data information  
- **Spring framework:** an open source framework used to develop java based applications.
- **Apache Maven:** a project management and comprehension tool.

### How to test our microservice
- **Start docker:**
  ```bash
    $ docker start
  ```
- **Create a .env file inside "Progetto3ACarusoFallicaDSBD" with the following arguments:**
  ```dotenv
    DB_DATABASE = #Your DB name
    DB_USER = #Your DB user
    DB_PASSWORD = #Your DB password
    DB_ROOT_PASSWORD = #Your DB root password
    DB_HOST = #Your DB host name
    DB_PORT = #Your DB port number
    PAYMENT_MANAGER_HOST = #Host name of payment microservice, we used "paymentmanager"
    PAYMENT_MANAGER_PORT = #Payment microservice port
    MY_PAYPAL_ACCOUNT = #Receiver business mail, we used "merchange@mydomain.tld"
    HEART_BEAT_PERIOD = #Period of the heartbeating routine expressed in ms
    HEART_BEAT_URL_PING = #URL that will be used by the heartbeating routine for the POST request.
  ```
  
- **Open a terminal inside "Progetto3ACarusoFallicaDSBD" then use the following command:**
  ```bash  
  $ docker-compose up -build
  ```

---

## 2. POJO classes
In order to easily generate messages and JSON data, we've used the following POJO classes:
- **Kafka Message & Kafka Value:**
  in our project we use Kafka to publish different kind of information into specific topics.
  All the messages have the same base structure made of a "message key", and a "message body", so we've created a base class for the message body called
  "KafkaValue" that is specialized into different kind of Values:
  * **KafkaErrorValue:** value used for the messages published into "logging" topic, with a proper error key.
  * **KafkaHttpValue:** value used for the messages published into "logging" topic, with key "http_errors".
  * **KafkaOrderValue:** value used for the messages published into "orders" topic, with key "order_paid".
  
  ![KafkaMessages](./diagrams/kafkamessages.svg)
  

- **Ipn & PaypalIpn:**
  in our project we have two different kind of services to handle ipn:
  * **Simulated Ipn:** this service is used to simulate the reception of an Ipn. 
  This service will use Ipn POJO class, that contains only the most important attributes of an Ipn.
    
    ![KafkaMessages](./diagrams/ipn.svg)
  * **Real Ipn:** this service is used to receive a real Ipn, using Paypal sandbox service.
  For this we've used PaypalIpn POJO class, that contains all the attributes that a real Ipn could have.
  

- **Return Message:**
  When a http error is generated, the HttpExceptionController captures it and generates a return message using this POJO class.
  
  ![KafkaMessages](diagrams/http.svg)

    
---

## 3. Kafka & Heartbeat
Our microservice uses Kafka messaging system to publish into two topics, different kind of system info:
- **Logging topic:** this topic is used to log all the error messages generated by our microservice.
  There are different kind of errors:
  * `Received_wrong_business_paypal_payment`: this error message is generated by the service class when the ipn received by Paypal contains a wrong receiver business mail 
  * `Bad_ipn_error`: this error message is generated by the service class when the received paypal request cannot be verified.
  * `Http_error`: this error message is generated when the HttpExceptionController captures a http error.
- **Orders topic:** this topic is used to log all the messages with `order_paid` key. This kind of messages are generated when an ipn has been successfully verified and saved into the payment table of the database.

Information published by our microservice are ready to be consumed by other components that use Kafka.

In our projects we used the interface "Configuration" to implements the following classes:
- **KafkaProducerConfig:** class used to create our topics and to expose a "KafkaTemplate" that is used by the payment service to publish our microservice information.
- **Heartbeater:** class that implements hear-beat mode ping strategy.

Our heartbeater class repeats periodically the function "heartbeat()", that will check our DB connection using a simple select query, and then makes a POST request at `HEART_BEAT_URL_PING` 
with the following body:
```JSON
{
  "service": "serviceName",
  "serviceStatus": "up|down",
  "dbStatus": "up|down"
}
```

The following UML diagrams shows the interfaces used for our "Heartbeater" and "KafkaProducerConfig" classes:

![Kafka](./diagrams/kafka.svg)

---

## 4. Payment controller & Payment service
As requested, our Payment Controller class exposes the following endpoints:
- `POST payment/ipn`: this HTTP endpoint is used to simulate a payment notification coming from Paypal system.
  
  The request must contain and Header called "X-User-ID" that contains an userId which is used by the Paypal Service to correctly generate a Payment entry. 
  
  In this particular scenario, our Payment Service class requires a "simulated ipn" argument to generate a Payment entry: the verify function will always return a "true" value.

  In order to easily check if the body of the request has everything that is needed to generate a Payment entry, we created a POJO class called "Ipn": the following JSON shows a correct request body according to the Ipn class:
  ``` JSON
  {
    "invoice":"asjldfbksdag224",
    "item_id":13,
    "mc_gross":124.12,
    "business":"merchange@mydomain.tld"
  } 
  ```
  
  If the Payment entry is successfully created, all the information about the payment will be returned as shown below:
  ``` JSON  
  {
    "id": 27,
    "userId": 13,
    "orderId": "asjldfbksdag224",
    "amountPayed": 124.12,
    "createdAt": "2021-01-19T21:54:01.021+00:00",
    "modifiedAt": "2021-01-19T21:54:01.021+00:00"
  }
  ```
- `POST payment/real_ipn`: we introduced this HTTP endpoint to use the real Paypal system to receive a payment notification.
  
  As the previous endpoint, the request must contain an UserId: in this particular scenario the request is coming from Paypal, so we can't receive this value with the Header called "X-User-ID".
  
  To avoid this problem, the payment url must be created with an optional value `on0` used to contain the userId.
  
  The following JSON structure can be used to generate a payment URL:
  ``` JSON
   params = {
    'business': 'https://www.sandbox.paypal.com/cgi-bin/webscr',
    'cmd': '_xclick',
    'invoice': my_order_id,
    'amount': my_price,
    'item_name': 'my_order_string_reference',
    'item_number': 'order_user_id',
    'quantity': 1,
    'currency_code': 'EUR',
    'notify_url': my_ngrok_url + "/payment/real_ipn",
    'on0': '0'
  }
  ```

  In this scenario, our Payment Service class receives a "Paypal Ipn" from Paypal, and in this case the verify function will make a POST request to paypal to verify the Ipn.

  If the received Ipn is valid, a Payment entry will be created and all the information about it will be returned like the previous endpoint.
  

The following UML diagram shows the interfaces used for our "PaymentController" and "PaymentService" classes:

![Controller](./diagrams/controller.svg)
---

## 5. Error handling
![HttpExceptionController](./diagrams/http.svg)
---

